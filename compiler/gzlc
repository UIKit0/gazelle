#!/usr/bin/env lua
--[[--------------------------------------------------------------------

  Gazelle: a system for building fast, reusable parsers

  gzlc

  The top-level file for compiling an input grammar (written in a
  human-readable text format) into a compiled grammar in Bitcode.

  Copyright (c) 2007 Joshua Haberman.  See LICENSE for details.

--------------------------------------------------------------------]]--

-- Include functionality for all parts of the compiler.

-- parsing of the input grammar file
require "bootstrap/rtn"

-- FA manipulation
require "nfa_to_dfa"
require "minimize"

-- lookahead calculation
require "ll"
require "intfa_combine"

-- output generation
require "bytecode"

require "pp"

usage = [[
Gazelle grammar compiler (v0.2-prerelase)
gzlc [options] input-file

Options:
  -h, --help         you're looking at it.

  -o <file>          output filename.  Default is input filename
                     with extension replaced with .gzc

  -v, --verbose      dump information about compilation process and
                     output statistics.

  --version          dump Gazelle version
]]

version = "Gazelle v0.2-prerelease"

-- parse options
input_filename = nil
output_filename = nil
verbose = false
argnum = 1
while argnum <= #arg do
  local a = arg[argnum]
  if a == "-h" or a == "--help" then
    stderr:write(usage)
    os.exit(1)
  elseif a == "-o" then
    argnum = argnum + 1
    output_filename = arg[argnum]
    if output_filename == nil then
      stderr:write("gzlc: argument -o must be followed by a file name\n")
      os.exit(1)
    end
  elseif a == "-v" or a == "--verbose" then
    verbose = true
  elseif a == "--version" then
    print(version)
    os.exit(0)
  else
    if input_filename then
      stderr:write("gzlc: only one input file may be specified\n")
      os.exit(1)
    end
    input_filename = arg[argnum]
  end
  argnum = argnum + 1
end

if input_filename == nil then
  io.stderr:write("gzlc: no input file\n")
  os.exit(1)
end

if output_filename == nil then
  output_file = input_filename:gsub("%.[^%.]*$", "") .. ".gzc"
end

function print_verbose(str)
  if verbose then
    print(str)
  end
end

function write_verbose(str)
  if verbose then
    io.stdout:write(str)
  end
end

print_verbose(version)


-- open and parse the grammar file

print_verbose(string.format("Opening input file '%s'...", input_filename))
input_file = io.open(input_filename, "r")
grm_str = input_file:read("*a")
if not input_file then
  stderr:write(string.format("gzlc: couldn't open input file '%s'", input_filename))
end

print_verbose("Parsing grammar...")
grammar, attributes = parse_grammar(CharStream:new(grm_str))
nonterms = {}
for k, _ in pairs(grammar) do table.insert(nonterms, k) end

-- make the RTNs in the grammar determistic and minimal

write_verbose("Convering RTN NFAs to DFAs...")
for nonterm in each(nonterms) do
  grammar[nonterm] = nfa_to_dfa(grammar[nonterm])
  write_verbose(".")
end
write_verbose("\n")

write_verbose("Minimizing RTN DFAs...")
for nonterm in each(nonterms) do
  grammar[nonterm] = hopcroft_minimize(grammar[nonterm])
  write_verbose(".")
end
write_verbose("\n")


-- do lookahead calculations
k = 2
print_verbose(string.format("Doing LL(k) lookahead calculations (capped at k=%d)", k))
-- status, err = pcall(compute_lookahead, grammar, k)
-- if not status then
--   io.stderr:write(string.format("Error computing lookahead: %s\n", err))
--   os.exit(1)
-- end
compute_lookahead(grammar, k)

if verbose then
  print_verbose("Lookahead calculations complete.  Grammar is:")
  lookahead_hist = {}
  total_states = 0
  for nonterm, rtn in pairs(grammar) do
    for state in each(rtn:states()) do
      total_states = total_states + 1
      this_state_k = 0
      if state.lookahead then
        for triple in each(state.lookahead) do
          local seq = unpack(triple)
          if #seq > this_state_k then
            this_state_k = #seq
          end
        end
      end
      lookahead_hist[this_state_k] = lookahead_hist[this_state_k] or 0
      lookahead_hist[this_state_k] = lookahead_hist[this_state_k] + 1
    end
  end

  for this_k = 0,k do
    if lookahead_hist[this_k] then
      local count = lookahead_hist[this_k]
      print_verbose(string.format("  %5.1f%% LL(%d)  (%d/%d states)", count*100/total_states, this_k, count, total_states))
    end
  end
end

-- we now have everything figured out at the RTN level.  Now we just need
-- to figure out how many IntFAs to generate, which terminals each one
-- should handle, and generate/determinize/minimize those IntFAs.
print_verbose("Combining lexer IntFAs...")
intfas = intfa_combine(attributes.terminals, grammar)


-- vim:et:sts=2:sw=2
