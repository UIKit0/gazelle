#!/usr/bin/env lua
--[[--------------------------------------------------------------------

  Gazelle: a system for building fast, reusable parsers

  gzlc

  The top-level file for compiling an input grammar (written in a
  human-readable text format) into a compiled grammar in Bitcode.

  Copyright (c) 2007 Joshua Haberman.  See LICENSE for details.

--------------------------------------------------------------------]]--

require "bootstrap/rtn"
require "grammar"
require "bytecode"
require "ll"

require "pp"

usage = [[
Gazelle grammar compiler (v0.2-prerelase)
gzlc [options] input-file

Options:
  -h, --help         you're looking at it.

  -d,                dump detailed output about the grammar to
                     html/index.html.

  -o <file>          output filename.  Default is input filename
                     with extension replaced with .gzc

  -v, --verbose      dump information about compilation process and
                     output statistics.

  --version          dump Gazelle version
]]

version = "Gazelle v0.2-prerelease"

-- parse options
input_filename = nil
output_filename = nil
verbose = false
dump = false
argnum = 1
while argnum <= #arg do
  local a = arg[argnum]
  if a == "-h" or a == "--help" then
    io.stderr:write(usage)
    os.exit(1)
  elseif a == "-d" then
    dump = true
  elseif a == "-o" then
    argnum = argnum + 1
    output_filename = arg[argnum]
    if output_filename == nil then
      stderr:write("gzlc: argument -o must be followed by a file name\n")
      os.exit(1)
    end
  elseif a == "-v" or a == "--verbose" then
    verbose = true
  elseif a == "--version" then
    print(version)
    os.exit(0)
  else
    if input_filename then
      stderr:write("gzlc: only one input file may be specified\n")
      os.exit(1)
    end
    input_filename = arg[argnum]
  end
  argnum = argnum + 1
end

if input_filename == nil then
  io.stderr:write("gzlc: no input file\n")
  os.exit(1)
end

if output_filename == nil then
  output_filename = input_filename:gsub("%.[^%.]*$", "") .. ".gzc"
end

function print_verbose(str)
  if verbose then
    print(str)
  end
end

function write_verbose(str)
  if verbose then
    io.stdout:write(str)
  end
end

print_verbose(version)


-- We need to generate and emit RTNs, GLAs, and IntFAs.  We work from the
-- top down: RTNs are generated from parsing the grammar, GLAs are
-- calculated from the RTNs by LL lookahead routines, and finally
-- IntFAs are generated from the RTNs and GLAs.

-- open and parse the grammar file

print_verbose(string.format("Opening input file '%s'...", input_filename))
input_file = io.open(input_filename, "r")
grm_str = input_file:read("*a")
if not input_file then
  stderr:write(string.format("gzlc: couldn't open input file '%s'", input_filename))
end

print_verbose("Parsing grammar...")
grammar = parse_grammar(CharStream:new(grm_str))

-- make the RTNs in the grammar determistic and minimal
print_verbose("Convering RTN NFAs to DFAs...")
grammar:determinize_rtns()
print_verbose("Minimizing RTN DFAs...")
grammar:minimize_rtns()

-- Generate GLAs by doing lookahead calculations.
-- This annotates every nontrivial state in the grammar with a GLA.
print_verbose("Doing LL(k) lookahead calculations...")
compute_lookahead(grammar)

-- we now have everything figured out at the RTN and GLA levels.  Now we just
-- need to figure out how many IntFAs to generate, which terminals each one
-- should handle, and generate/determinize/minimize those IntFAs.

print_verbose("Generating lexer DFAs...")
grammar:generate_intfas()

print_verbose(string.format("Writing to output file '%s'...", output_filename))
write_bytecode(grammar, output_filename)

if dump then
  require "dump_to_html"
  dump_to_html(input_filename, grammar, "html")
end

-- vim:et:sts=2:sw=2
